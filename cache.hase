// Project:	Snoopy Cache Coherence V7: Copy Back / Write Invalidate 
// Entity	Cache
// File	cache.hase
// Date:	Dec 2006, revised Nov 2010,  Mar 2019
// Author:	Roland Ibbett

/* Each line in the cache contains the following (integer) fields in each of its lines:
Valid
Modified
Address
Data0
Data1
Data2
Data3

A cache line can be Valid or Modified (but not both) or Invalid

Bus packets can contain the following fields:
Address
Data
Source: Number of the originating cache
Instruction, which can be one of the following:

BR	Bus Read Request  (to other caches)
MR	Memory Read Request
RR	Memory Read Response - includes data
MW	Memory Write Request
WR	Memory Write Response
IV	Invalidate

A cache receives packets from its processor and from the bus.
A packet from a processor can be a read request or a write request.
The actions that occur depend on the current state of the line.

RH (valid)		- supply data to processor, state remains unchanged
RHM (modified)	- supply data to processor, state remains unchanged

RMM (modified)	- Write existing data to memory, change state to RM and proceed as for RM

RM (unmodified)	- send Bus Read Request (BR) to bus
				- wait one clock cycle: if another cache has a Modified value, 
				   it writes the value to memory during this cycle and sets itself Valid
				- issue Memory Read (MR); when memory replies:
				- change state to Valid, update cache and supply data to processor

WH (valid)		- send Invalidate packet to bus, write data and set state to Modified
				  (for the line to be Valid, there can't be a Modified copy in any other cache)

WHM (modified)	- write data,  state remains unchanged

WMM (modified)	- write existing data to memory (MW), then as for unmodified

WM (unmodified)	- send Invalidate (IV) to bus
				- wait one clock cycle: if another cache has a Modified value, it writes the
				  value to memory during this cycle and sets itself Invalid;
				  else if other caches have Valid copies, they set them to Invalid
				- issue Memory Read (MR)
				- when memory replies, update cache with data from memory
				  and then from processor (to allow for multi-word lines)
*/

$class_decls

// entity reference

  bus * myBus;
  memory* myMem;

//structures and variables

bool BusMaster, invalidating;
bool read_request, read_hit, write_request, write_hit, no_request, read_miss_mod, write_miss_mod;
bool cb_done, cb_slot, cb_wait1, cb_wait2;
bool request_bus_control, send_copyback;
bool send_mem_read, send_bus_read, send_write, send_invalidate, send_to_proc;
bool force_recheck;
bool done;

char bus_instr[5], proc_instr[5];

int count, i;
int own_no;
char * name;
int line,  line_mask, word_select;
int bus_cache_line, bus_line_address;
int proc_cache_line, proc_line_address;
int pkt_to_proc;
int accesses, hits, hit_rate;

t_cache_struct cache_buff, bus_buff;
t_mem_trace pkt_from_proc;
t_read_mem bus_read_request, read_req_pkt;
t_write_mem bus_write_request, invalidate_request, null_pkt;
t_read_reply read_reply;
t_write_reply write_reply;

void handle_read();
void handle_write();
void handle_read_reply();
void copyback();
void invalidate();
void recheck_cache();

$class_defs

void cache::handle_read()
{	
/*
	Called when the cache receives a Read Request; result may be a Read Hit (RH) or Read Miss (RM)
	RH:
		If  cache_buff.address = pkt_from_proc.addr & (Valid or Modified)
		
	RMM:
		If cache_buff.address != pkt_from_proc.addr & Modified = 1

		1. Write existing data to memory (WM)

		2. Proceed as for Read Miss Unmodified
		If Valid = 0 
	or	if Valid = 1 & cache_buff.address != pkt_from_proc.addr &  Modified = 0)

		1. Send Read Request (BR) to Bus
		2. Release Bus and wait one clock cycle; if another cache has a modified value (only 1 can),
				 it writes the value to memory during this cycle and sets itself Valid & Unmodified
		3. If there's no write or when the write is complete, Issue Memory Read (MR)
		4. When memory replies (RR), write data to and supply to processor
*/

  read_request = true;
  Address = pkt_from_proc.addr;
  proc_line_address = pkt_from_proc.addr >> 2;
  proc_cache_line = proc_line_address & line_mask;
  cache_buff = cache_mem[proc_cache_line];
  word_select = pkt_from_proc.addr & 3;

  if  ( (cache_buff.address == proc_line_address) && ( (cache_buff.valid == 1) || (cache_buff.modified == 1) ) )
   {
					// read hit - select data word from cache line and send to processor
      read_hit = true;
      if (cache_buff.valid == 1)
	{strcpy(Status, "RH");}
      else
	{strcpy(Status, "RHM");}

    switch (word_select)
      {
	case 0:
		pkt_to_proc = cache_buff.data0;
		break;
	case 1:
		pkt_to_proc = cache_buff.data1;
		break;
	case 2:
		pkt_to_proc = cache_buff.data2;
		break;
	case 3:
		pkt_to_proc = cache_buff.data3;
		break;
      }
    send_to_proc = true;
    }										// end of read hit
  else									// read miss 
   {
     if (cache_buff.modified == 0)				// read miss unmodified
     {										// first send Bus Read Request
	strcpy(Status, "RM");
	strcpy (bus_read_request.instr,"BR");
	bus_read_request.addr = proc_line_address;
	bus_read_request.source = own_no;
	if (!read_miss_mod)
	 {request_bus_control = true;}
	read_miss_mod = false;
	send_bus_read = true;
     }
    else									// read miss modified - need to copy back line
     {
	strcpy(Status, "RMM");
	read_miss_mod = true;					// used to determine what to do next after memory replies
	strcpy(bus_write_request.instr,"MW");
	bus_write_request.addr = cache_buff.address;
	bus_write_request.data0 = cache_buff.data0;
	bus_write_request.data1 = cache_buff.data1;
	bus_write_request.data2 = cache_buff.data2;
	bus_write_request.data3 = cache_buff.data3;
	bus_write_request.source = own_no;
	send_write = true;
	request_bus_control = true; 
     }
   }										// end of read miss
	 dump_state();
}										// end of handle read

void cache::handle_write()
{
/* 
   Called when the cache receives a Write Request; result may be a Write Hit unmodified (WH),  a
   Write Hit modified (WHM), a Write Miss unmodified (WM) or a Write Miss Modified (WMM)

   WH:	- send Invalidate packet to bus, write data, set state to Modified

   WHM:	- write data, state unchanged, no other cache can have a copy, so no need to invalidate

   WM:	- send Bus Read Request (BR) to bus
		- wait one clock cycle: if another cache has a modified value, it writes the value to memory
			during this cycle and sets itself Invalid; if another cache has a valid unmodified copy,
			it sets it to Invalid
		- issue Memory Read (MR)
		- when memory replies, update cache buffer with data from processor, then update cache

   WMM	- Write existing data to memory (MW), then as for WM
*/

  write_request = true;
  Address = pkt_from_proc.addr;
  proc_line_address = pkt_from_proc.addr >> 2;
  proc_cache_line = proc_line_address & line_mask;
  cache_buff = cache_mem[proc_cache_line];
  word_select = pkt_from_proc.addr & 3;

 if ( (cache_buff.address == proc_line_address) && ( (cache_buff.valid == 1) || (cache_buff.modified == 1) ) )
  {														// write hit
     write_hit = true;
     switch (word_select)
      {
	case 0:
		cache_buff.data0 = pkt_from_proc.data;
		break;
	case 1:
		cache_buff.data1 = pkt_from_proc.data;
		break;
	case 2:
		cache_buff.data2 = pkt_from_proc.data;
		break;
	case 3:
		cache_buff.data3 = pkt_from_proc.data;
		break;
      }

     if (cache_buff.modified == 1)
      {													// write hit modified
       strcpy(Status, "WHM");
       cache_mem.Update(proc_cache_line, cache_buff);
       pkt_to_proc = 0;
       send_to_proc = true;
      }
    else
     {													// write hit unmodified
      strcpy(Status, "WH");
      cache_buff.valid = 0;
      cache_buff.modified = 1;		  // update cache when invalidate packet has been sent
      strcpy(bus_read_request.instr,"IV");	
      bus_read_request.addr = pkt_from_proc.addr;
      bus_read_request.source = own_no;
      send_invalidate = true;
      request_bus_control = true;
     }
   }												// end of write hit

  else											// write miss
    {
     if  (cache_buff.modified == 0)				// write miss unmodified - first send Bus Read Request 
       {	
	strcpy(Status, "WM");
	dump_state();
	strcpy (bus_read_request.instr,"BR");
	bus_read_request.addr = proc_line_address;
	bus_read_request.source = own_no;
	if (!write_miss_mod)
	 {request_bus_control = true;}
	write_miss_mod = false;
	send_bus_read = true;
       }
     else									// write miss modified - need to copy back line
       {
	strcpy(Status, "WMM");
	write_miss_mod = true;					// used to determine what to do next after memory replies
	strcpy(bus_write_request.instr,"MW");
	bus_write_request.addr = cache_buff.address;
	bus_write_request.data0 = cache_buff.data0;
	bus_write_request.data1 = cache_buff.data1;
	bus_write_request.data2 = cache_buff.data2;
	bus_write_request.data3 = cache_buff.data3;
	bus_write_request.source = own_no;
	request_bus_control = true;
	send_write = true;
       }
    }
     dump_state();
}										// end of handle write

void cache::handle_read_reply()
{

// 	When an RR packet is received, the data is copied into cache_buff.
//	If the reply is for a Read Request, the data in cache_buff is written to the selected line cache
//	and the required value from within the line is forwarded to the processor.
//	Otherwise the reply is for a Write Allocate request, so cache_buff is updated with the value from proc

	 cache_buff.valid = 1;
	 cache_buff.modified = 0;
	 cache_buff.address = proc_line_address;
	 cache_buff.data0 = read_reply.data0;
	 cache_buff.data1 = read_reply.data1;
	 cache_buff.data2 = read_reply.data2;
	 cache_buff.data3 = read_reply.data3;

 if (read_request)
  {
    cache_mem.Update(proc_cache_line,cache_buff);
    switch (word_select)
      {
	case 0:
		pkt_to_proc = cache_buff.data0;
		break;
	case 1:
		pkt_to_proc = cache_buff.data1;
		break;
	case 2:
		pkt_to_proc = cache_buff.data2;
		break;
	case 3:
		pkt_to_proc = cache_buff.data3;
		break;
      }
   send_to_proc = true;
   myBus->BusBusy = false;			// release bus
   BusMaster = false;
  }
 else								//  read request for write allocate
  {
    switch (word_select)
      {
	case 0:
		cache_buff.data0 = pkt_from_proc.data;
		break;
	case 1:
		cache_buff.data1 = pkt_from_proc.data;
		break;
	case 2:
		cache_buff.data2 = pkt_from_proc.data;
		break;
	case 3:
		cache_buff.data3 = pkt_from_proc.data;
		break;
       }

  cache_buff.valid = 0;
  cache_buff.modified = 1;
  cache_mem.Update(proc_cache_line, cache_buff);
  pkt_to_proc = 0;
  send_to_proc = true;
  write_request = false;
  myBus->BusBusy = false;				// release bus
  BusMaster = false;
   }									//  end of read request for write allocate
 }									// end of handle_read_reply

void cache::copyback()				// if line is modified
{
  bus_line_address =  read_req_pkt.addr;
  bus_cache_line = bus_line_address & line_mask;
  bus_buff = cache_mem[bus_cache_line];
  if ( (bus_buff.address == bus_line_address) && (bus_buff.modified == 1))
   {
    strcpy (bus_write_request.instr,"MW");	
    bus_write_request.addr = proc_line_address;
    bus_write_request.data0 = cache_buff.data0;
    bus_write_request.data1 = cache_buff.data1;
    bus_write_request.data2 = cache_buff.data2;
    bus_write_request.data3 = cache_buff.data3;
    bus_write_request.source = own_no;
    bus_buff.modified = 0;							// bus_buff.valid = 0 already
    cache_mem.Update(bus_cache_line, bus_buff);
    send_copyback = true; 
    force_recheck = true;
   }
}

void cache::invalidate()				// invalidate a matching line if it's valid (it's not possible for there
								// to be a modified line when an invalidate packet is sent)
{
  bus_line_address = invalidate_request.addr;
  bus_cache_line = bus_line_address & line_mask;
  bus_buff = cache_mem[bus_cache_line];
  if ( (bus_buff.address == bus_line_address) && (bus_buff.valid == 1))
   {
    strcpy(Status, "INV");
    my_state = CACHE_INV;
    dump_state_i();
    bus_buff.valid = 0;
    cache_mem.Update(bus_cache_line, bus_buff);
   }
}

void cache::recheck_cache(){

//  If a cache line is updated by a Write Request from another cache,
//  it must re-check any outstanding processor requests at the start of the next clock period.

      request_bus_control = false;
      send_mem_read = false;
      send_bus_read = false;
      send_write = false;
      send_invalidate = false;
      if (read_request) 
       {handle_read();}
      if (write_request)
       {handle_write();}
      force_recheck = false;  
}

$pre

// set up pointer to bus

myBus = (bus*)sim.get_entity(sim.get_entity_id("BUS"));
myMem = (memory*)sim.get_entity(sim.get_entity_id("MEMORY"));

  BusMaster = false;
  invalidating = false;
  done = false;
  request_bus_control = false;
  read_request = false;
  write_request = false;
  no_request = false;
  read_miss_mod = false;
  write_miss_mod = false;
  send_copyback = false;
  send_mem_read = false;
  send_bus_read = false;
  send_write = false;
  send_invalidate = false;
  send_to_proc = false;
  force_recheck = false;
  cb_done = false;
  cb_slot = false;
  cb_wait1 = false;
  cb_wait2 = false;

  name = get_name();
  if (strcmp(name,"CACHE1")==0) {own_no=1;}
  if (strcmp(name,"CACHE2")==0) {own_no=2;}
  if (strcmp(name,"CACHE3")==0) {own_no=3;}
  if (strcmp(name,"CACHE4")==0) {own_no=4;}

// Initialise Cache, setting all cache line values to 0

  line_mask = Cache_size - 1;
  accesses = 0;
  hits = 0;
  hit_rate = 0;

  cache_buff.valid = 0;
  cache_buff.address = 0;
  cache_buff.data0 = 0;
  cache_buff.data1 = 0;
  cache_buff.data2 = 0;
  cache_buff.data3 = 0;
  for (count=0;count<Cache_size;count++)
    {cache_mem.Update(count,cache_buff);}

  my_state = CACHE_IDLE;
  dump_state();

$phase0

  sim_from_port P_Input(from_proc);	    
  sim_from_port B_Input(from_bus);	    

 if (force_recheck)
    {recheck_cache();}

  if  (sim_waiting(ev, B_Input) > 0) 							 // packet from bus
   {
    if (ev.type() == READ_MEM_PKT)						// could be BR or RM; ignore if RM
     {
      SIM_CAST_DEL(t_read_mem, read_req_pkt,ev);
      if (strcmp (read_req_pkt.instr, "BR") == 0)					// Bus Read Request
       { copyback();}							// check if there's a matching modified line; if so, write back
      }

     if (ev.type() == WRITE_MEM_PKT) 
     {
      SIM_CAST_DEL(t_write_mem, null_pkt,ev);
      if (cb_slot) 								// another cache is copying back; else no nothing
       {
	cb_wait2 = true;
	cb_slot = false;
       }
     }

   if (ev.type() == INVALIDATE_PKT)						// invalidate a valid matching entry
     {
	SIM_CAST_DEL(t_write_mem, invalidate_request,ev);
	invalidating = true;
	invalidate();
     }

    if (ev.type() == READ_REPLY_PKT)						// update cache if source = own_no
     {
	SIM_CAST_DEL(t_read_reply, read_reply,ev);
	if  (read_reply.source == own_no)
	 {handle_read_reply();}
     }

    if (ev.type() == WRITE_REPLY_PKT)						// send Ack to proc if source = own_no
     {
	SIM_CAST_DEL(t_write_reply, write_reply,ev);
	if (cb_wait2)
	 {
	  cb_done = true;								// a different cache has completed its copyback
	  cb_wait2 = false;
	 }

	if (write_reply.source == own_no)
	 {
	   if (read_miss_mod)
	    {
	     cache_buff.modified = 0;
	     cache_mem.Update(proc_cache_line,cache_buff);
	     handle_read();								// i.e. again
	    }
 	   if (write_miss_mod)
	    {
	     cache_buff.modified = 0;
	     cache_mem.Update(proc_cache_line,cache_buff);
	     handle_write();								// i.e. again
	    }
       }
     }
   }
 else
  {
   if (cb_slot)
    {
     cb_done = true;
     cb_slot = false;
    }
  }

  if  (sim_waiting(ev, P_Input) > 0)	// pkt from processor
   {
    nodes_done_mutex.Lock();
    nodes_done--;
    dump_globals();
    nodes_done_mutex.Unlock(); 
    accesses ++;
    my_state = CACHE_BUSY;
    dump_state_i();
    SIM_CAST(t_mem_trace, pkt_from_proc,ev);
    strcpy(proc_instr,pkt_from_proc.instr);
    if  (strcmp(proc_instr,"R") == 0)
	 {handle_read();}
	if (strcmp(proc_instr,"r") == 0)
	 {handle_read();}
	if (strcmp(proc_instr,"W") == 0)
	  {handle_write();}
	if (strcmp(proc_instr,"w") == 0)
	  {handle_write();}
    }

$phase1

  if (send_to_proc)
  {
    send_PROC_PKT_I(to_proc, pkt_to_proc);
    done = true;
    if (read_hit || write_hit)
     {
	hits ++;
	read_hit = false;
	write_hit = false;
      }
    read_request = false;
    write_request = false;
    send_to_proc = false;
    my_state = CACHE_IDLE;
    dump_state();
  }

if (!(invalidating))
 {
  if (request_bus_control)
   {
    if (own_no == 1)
      {myBus->C1_request = true;}
    else if (own_no == 2)
      {myBus->C2_request = true;}
    else if (own_no == 3)
      {myBus->C3_request = true;}
    else if (own_no == 4)
      {myBus->C4_request = true;}
    request_bus_control = false;
   }

 if (cb_wait1)
  {
   cb_slot = true;
   cb_wait1 = false;
  }

  sim_hold(2);

  if ((own_no == 1) && (myBus->BusGrant1))
   {
     BusMaster = true;
     myBus->BusGrant1 = false;
   }

  if ((own_no == 2) && (myBus->BusGrant2))
   {
     BusMaster = true;
     myBus->BusGrant2 = false;
   }

  if ((own_no == 3) && (myBus->BusGrant3))
   {
     BusMaster = true;
     myBus->BusGrant3 = false;
   }

  if ((own_no == 4) && (myBus->BusGrant4))
   {
     BusMaster = true;
     myBus->BusGrant4 = false;
   }

  if (send_copyback)							// doesn't need to be BusMaster
   {
    send_WRITE_MEM_PKT(to_bus, bus_write_request);
    send_copyback = false;
   }

  if (cb_done)
   {
    strcpy (bus_read_request.instr,"MR");	//  after BR delay, send Memory Read request
    send_mem_read = true;
    cb_done = false;
   }

  if (BusMaster)
   {
     my_state = BUS_MAST;
     dump_state_i();

     if (send_bus_read)
      {
       send_READ_MEM_PKT(to_bus, bus_read_request);
       cb_wait1 = true;
       send_bus_read = false;
     }

      if (send_mem_read)
      {
       send_READ_MEM_PKT(to_bus, bus_read_request);
       send_mem_read = false;
      }

    if (send_write)
      {
        send_WRITE_MEM_PKT(to_bus, bus_write_request);
        send_write = false;
      }

     if (send_invalidate)					// occurs if WH (unmodified); instr field is set to IV
      {
       send_INVALIDATE_PKT(to_bus, bus_read_request);
       cache_mem.Update(proc_cache_line, cache_buff);
       send_invalidate = false;
       pkt_to_proc = 0;
       send_to_proc = true;
       BusMaster = false;
       myBus->BusBusy = false;				// release bus
      }
    }									// end of BusMaster
  }									// end of ! invalidating
  else								// invalidating
  {
   force_recheck = true;
   invalidating = false;
   strcpy(Status, "__");
   my_state = CACHE_IDLE;
   dump_state_i();
 }

  if (no_request || (nodes_done == 4))
   {
    strcpy(Status, "__");
    my_state = CACHE_IDLE;
    dump_state_i();
    no_request = false;
   }

  if (done)
   {
    strcpy(Status, "__");
    my_state = CACHE_IDLE;
    dump_state_i();
    nodes_done_mutex.Lock();
    nodes_done++;
    dump_globals();
    nodes_done_mutex.Unlock();
    done = false;
   }

$report

// Copy back to Memory any lines that have been modified

for (i=0; i<8; i++)
 {
   cache_buff = cache_mem[i];
   if (cache_buff.modified == 1)
    {
      myMem->mem_buff.data0 = cache_buff.data0;
      myMem->mem_buff.data1 = cache_buff.data1;
      myMem->mem_buff.data2 = cache_buff.data2;
      myMem->mem_buff.data3 = cache_buff.data3;
      myMem->address = cache_buff.address;
      myMem->data_mem.Update(myMem->address, myMem->mem_buff);
    }
  }

  if(accesses > 0)
   {
     hit_rate = 100 * hits / accesses;
     printf("Cache%d accesses = %d,  hit rate = %d%% \n", own_no, accesses, hit_rate);
    }